/* WARNING: This file is automatically generated. Do not edit. */
import { TypedDocumentNode as DocumentNode } from "@graphql-typed-document-node/core";
import gql from "graphql-tag";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = {
  [_ in K]?: never;
};
export type Incremental<T> =
  | T
  | { [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: { input: string; output: string };
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any };
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
   * 3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
   * that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
   * to unexpected results.
   */
  Datetime: { input: string; output: string };
  Tag: { input: string; output: string };
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: { input: string; output: string };
  Url: { input: string; output: string };
  Username: { input: string; output: string };
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly newPassword: Scalars["String"]["input"];
  readonly oldPassword: Scalars["String"]["input"];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

export type Comment = {
  readonly body: Scalars["String"]["output"];
  /** Reads and enables pagination through a set of `Comment`. */
  readonly childComments: CommentsConnection;
  readonly createdAt: Scalars["Datetime"]["output"];
  readonly currentUserVoted?: Maybe<VoteType>;
  readonly id: Scalars["UUID"]["output"];
  /** Reads a single `Comment` that is related to this `Comment`. */
  readonly parent?: Maybe<Comment>;
  readonly parentId?: Maybe<Scalars["UUID"]["output"]>;
  readonly popularity?: Maybe<Scalars["Float"]["output"]>;
  /** Reads a single `Post` that is related to this `Comment`. */
  readonly post?: Maybe<Post>;
  readonly postId: Scalars["String"]["output"];
  readonly score?: Maybe<Scalars["Int"]["output"]>;
  readonly updatedAt: Scalars["Datetime"]["output"];
  /** Reads a single `User` that is related to this `Comment`. */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars["UUID"]["output"]>;
};

export type CommentChildCommentsArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<CommentCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<CommentsOrderBy>>;
};

/** A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CommentCondition = {
  /** Checks for equality with the object’s `id` field. */
  readonly id?: InputMaybe<Scalars["UUID"]["input"]>;
  /** Checks for equality with the object’s `parentId` field. */
  readonly parentId?: InputMaybe<Scalars["UUID"]["input"]>;
  /** Checks for equality with the object’s `postId` field. */
  readonly postId?: InputMaybe<Scalars["String"]["input"]>;
};

/** An input for mutations affecting `Comment` */
export type CommentInput = {
  readonly body: Scalars["String"]["input"];
  readonly parentId?: InputMaybe<Scalars["UUID"]["input"]>;
};

/** Represents an update to a `Comment`. Fields that are set will be updated. */
export type CommentPatch = {
  readonly body?: InputMaybe<Scalars["String"]["input"]>;
};

/** A connection to a list of `Comment` values. */
export type CommentsConnection = {
  /** A list of edges which contains the `Comment` and cursor to aid in pagination. */
  readonly edges: ReadonlyArray<CommentsEdge>;
  /** A list of `Comment` objects. */
  readonly nodes: ReadonlyArray<Comment>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The count of *all* `Comment` you could get from the connection. */
  readonly totalCount: Scalars["Int"]["output"];
};

/** A `Comment` edge in the connection. */
export type CommentsEdge = {
  /** A cursor for use in pagination. */
  readonly cursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** The `Comment` at the end of the edge. */
  readonly node: Comment;
};

/** Methods to use when ordering `Comment`. */
export type CommentsOrderBy =
  | "ID_ASC"
  | "ID_DESC"
  | "NATURAL"
  | "PARENT_ID_ASC"
  | "PARENT_ID_DESC"
  | "POST_ID_ASC"
  | "POST_ID_DESC"
  | "PRIMARY_KEY_ASC"
  | "PRIMARY_KEY_DESC";

/** All input for the `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly token: Scalars["String"]["input"];
};

/** The output of our `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** All input for the create `Comment` mutation. */
export type CreateCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The `Comment` to be created by this mutation. */
  readonly comment: CommentInput;
};

/** The output of our create `Comment` mutation. */
export type CreateCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The `Comment` that was created by this mutation. */
  readonly comment?: Maybe<Comment>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  readonly commentEdge?: Maybe<CommentsEdge>;
  /** Reads a single `Comment` that is related to this `Comment`. */
  readonly parent?: Maybe<Comment>;
  /** Reads a single `Post` that is related to this `Comment`. */
  readonly post?: Maybe<Post>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Comment`. */
  readonly user?: Maybe<User>;
};

/** The output of our create `Comment` mutation. */
export type CreateCommentPayloadCommentEdgeArgs = {
  orderBy?: ReadonlyArray<CommentsOrderBy>;
};

/** All input for the create `Post` mutation. */
export type CreatePostInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The `Post` to be created by this mutation. */
  readonly post: PostInput;
};

/** The output of our create `Post` mutation. */
export type CreatePostPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The `Post` that was created by this mutation. */
  readonly post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  readonly postEdge?: Maybe<PostsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Post`. */
  readonly user?: Maybe<User>;
};

/** The output of our create `Post` mutation. */
export type CreatePostPayloadPostEdgeArgs = {
  orderBy?: ReadonlyArray<PostsOrderBy>;
};

/** All input for the create `Task` mutation. */
export type CreateTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The `Task` to be created by this mutation. */
  readonly task: TaskInput;
};

/** The output of our create `Task` mutation. */
export type CreateTaskPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** The `Task` that was created by this mutation. */
  readonly task?: Maybe<Task>;
  /** An edge for our `Task`. May be used by Relay 1. */
  readonly taskEdge?: Maybe<TasksEdge>;
  /** Reads a single `User` that is related to this `Task`. */
  readonly user?: Maybe<User>;
};

/** The output of our create `Task` mutation. */
export type CreateTaskPayloadTaskEdgeArgs = {
  orderBy?: ReadonlyArray<TasksOrderBy>;
};

/** All input for the create `UserEmail` mutation. */
export type CreateUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The `UserEmail` to be created by this mutation. */
  readonly userEmail: UserEmailInput;
};

/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  readonly user?: Maybe<User>;
  /** The `UserEmail` that was created by this mutation. */
  readonly userEmail?: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  readonly userEmailEdge?: Maybe<UserEmailsEdge>;
};

/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: ReadonlyArray<UserEmailsOrderBy>;
};

/** All input for the `deleteComment` mutation. */
export type DeleteCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["UUID"]["input"];
};

/** The output of our delete `Comment` mutation. */
export type DeleteCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The `Comment` that was deleted by this mutation. */
  readonly comment?: Maybe<Comment>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  readonly commentEdge?: Maybe<CommentsEdge>;
  /** Reads a single `Comment` that is related to this `Comment`. */
  readonly parent?: Maybe<Comment>;
  /** Reads a single `Post` that is related to this `Comment`. */
  readonly post?: Maybe<Post>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Comment`. */
  readonly user?: Maybe<User>;
};

/** The output of our delete `Comment` mutation. */
export type DeleteCommentPayloadCommentEdgeArgs = {
  orderBy?: ReadonlyArray<CommentsOrderBy>;
};

/** All input for the `deletePost` mutation. */
export type DeletePostInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["String"]["input"];
};

/** The output of our delete `Post` mutation. */
export type DeletePostPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The `Post` that was deleted by this mutation. */
  readonly post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  readonly postEdge?: Maybe<PostsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Post`. */
  readonly user?: Maybe<User>;
};

/** The output of our delete `Post` mutation. */
export type DeletePostPayloadPostEdgeArgs = {
  orderBy?: ReadonlyArray<PostsOrderBy>;
};

/** All input for the `deleteTask` mutation. */
export type DeleteTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["UUID"]["input"];
};

/** The output of our delete `Task` mutation. */
export type DeleteTaskPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** The `Task` that was deleted by this mutation. */
  readonly task?: Maybe<Task>;
  /** An edge for our `Task`. May be used by Relay 1. */
  readonly taskEdge?: Maybe<TasksEdge>;
  /** Reads a single `User` that is related to this `Task`. */
  readonly user?: Maybe<User>;
};

/** The output of our delete `Task` mutation. */
export type DeleteTaskPayloadTaskEdgeArgs = {
  orderBy?: ReadonlyArray<TasksOrderBy>;
};

/** All input for the `deleteUserAuthentication` mutation. */
export type DeleteUserAuthenticationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["UUID"]["input"];
};

/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  readonly user?: Maybe<User>;
  /** The `UserAuthentication` that was deleted by this mutation. */
  readonly userAuthentication?: Maybe<UserAuthentication>;
};

/** All input for the `deleteUserEmail` mutation. */
export type DeleteUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["UUID"]["input"];
};

/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  readonly user?: Maybe<User>;
  /** The `UserEmail` that was deleted by this mutation. */
  readonly userEmail?: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  readonly userEmailEdge?: Maybe<UserEmailsEdge>;
};

/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: ReadonlyArray<UserEmailsOrderBy>;
};

/** All input for the `forgotPassword` mutation. */
export type ForgotPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly email: Scalars["String"]["input"];
};

/** The output of our `forgotPassword` mutation. */
export type ForgotPasswordPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
};

export type LoginInput = {
  readonly password: Scalars["String"]["input"];
  readonly username: Scalars["String"]["input"];
};

export type LoginPayload = {
  readonly user: User;
};

export type LogoutPayload = {
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** All input for the `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly emailId: Scalars["UUID"]["input"];
};

/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  readonly user?: Maybe<User>;
  readonly userEmail?: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  readonly userEmailEdge?: Maybe<UserEmailsEdge>;
};

/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayloadUserEmailEdgeArgs = {
  orderBy?: ReadonlyArray<UserEmailsOrderBy>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  /** Enter your old password and a new password to change your password. */
  readonly changePassword?: Maybe<ChangePasswordPayload>;
  /** If you're certain you want to delete your account, use `requestAccountDeletion` to request an account deletion token, and then supply the token through this mutation to complete account deletion. */
  readonly confirmAccountDeletion?: Maybe<ConfirmAccountDeletionPayload>;
  /** Creates a single `Comment`. */
  readonly createComment?: Maybe<CreateCommentPayload>;
  /** Creates a single `Post`. */
  readonly createPost?: Maybe<CreatePostPayload>;
  /** Creates a single `Task`. */
  readonly createTask?: Maybe<CreateTaskPayload>;
  /** Creates a single `UserEmail`. */
  readonly createUserEmail?: Maybe<CreateUserEmailPayload>;
  /** Deletes a single `Comment` using a unique key. */
  readonly deleteComment?: Maybe<DeleteCommentPayload>;
  /** Deletes a single `Post` using a unique key. */
  readonly deletePost?: Maybe<DeletePostPayload>;
  /** Deletes a single `Task` using a unique key. */
  readonly deleteTask?: Maybe<DeleteTaskPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  readonly deleteUserAuthentication?: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  readonly deleteUserEmail?: Maybe<DeleteUserEmailPayload>;
  /** If you've forgotten your password, give us one of your email addresses and we'll send you a reset token. Note this only works if you have added an email address! */
  readonly forgotPassword?: Maybe<ForgotPasswordPayload>;
  /** Use this mutation to log in to your account; this login uses sessions so you do not need to take further action. */
  readonly login?: Maybe<LoginPayload>;
  /** Use this mutation to logout from your account. Don't forget to clear the client state! */
  readonly logout?: Maybe<LogoutPayload>;
  /** Your primary email is where we'll notify of account events; other emails may be used for discovery or login. Use this when you're changing your email address. */
  readonly makeEmailPrimary?: Maybe<MakeEmailPrimaryPayload>;
  /** Use this mutation to create an account on our system. This may only be used if you are logged out. */
  readonly register?: Maybe<RegisterPayload>;
  /** Begin the account deletion flow by requesting the confirmation email */
  readonly requestAccountDeletion?: Maybe<RequestAccountDeletionPayload>;
  /** If you didn't receive the verification code for this email, we can resend it. We silently cap the rate of resends on the backend, so calls to this function may not result in another email being sent if it has been called recently. */
  readonly resendEmailVerificationCode?: Maybe<ResendEmailVerificationCodePayload>;
  /** After triggering forgotPassword, you'll be sent a reset token. Combine this with your user ID and a new password to reset your password. */
  readonly resetPassword?: Maybe<ResetPasswordPayload>;
  /** Updates a single `Comment` using a unique key and a patch. */
  readonly updateComment?: Maybe<UpdateCommentPayload>;
  /** Updates a single `Post` using a unique key and a patch. */
  readonly updatePost?: Maybe<UpdatePostPayload>;
  /** Updates a single `Task` using a unique key and a patch. */
  readonly updateTask?: Maybe<UpdateTaskPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  readonly updateUser?: Maybe<UpdateUserPayload>;
  /** Once you have received a verification token for your email, you may call this mutation with that token to make your email verified. */
  readonly verifyEmail?: Maybe<VerifyEmailPayload>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmAccountDeletionArgs = {
  input: ConfirmAccountDeletionInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostArgs = {
  input: CreatePostInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTaskArgs = {
  input: CreateTaskInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserEmailArgs = {
  input: CreateUserEmailInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommentArgs = {
  input: DeleteCommentInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostArgs = {
  input: DeletePostInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTaskArgs = {
  input: DeleteTaskInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationArgs = {
  input: DeleteUserAuthenticationInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailArgs = {
  input: DeleteUserEmailInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationForgotPasswordArgs = {
  input: ForgotPasswordInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationMakeEmailPrimaryArgs = {
  input: MakeEmailPrimaryInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterArgs = {
  input: RegisterInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationRequestAccountDeletionArgs = {
  input: RequestAccountDeletionInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationResendEmailVerificationCodeArgs = {
  input: ResendEmailVerificationCodeInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommentArgs = {
  input: UpdateCommentInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostArgs = {
  input: UpdatePostInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTaskArgs = {
  input: UpdateTaskInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};

/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars["Cursor"]["output"]>;
};

export type Post = {
  readonly body: Scalars["String"]["output"];
  /** Reads and enables pagination through a set of `Comment`. */
  readonly comments: CommentsConnection;
  readonly createdAt: Scalars["Datetime"]["output"];
  readonly currentUserVoted?: Maybe<VoteType>;
  readonly id: Scalars["String"]["output"];
  readonly popularity?: Maybe<Scalars["Float"]["output"]>;
  readonly privacy: Privacy;
  readonly score?: Maybe<Scalars["Int"]["output"]>;
  readonly tags: ReadonlyArray<Maybe<Scalars["Tag"]["output"]>>;
  readonly title: Scalars["String"]["output"];
  readonly updatedAt: Scalars["Datetime"]["output"];
  /** Reads a single `User` that is related to this `Post`. */
  readonly user?: Maybe<User>;
  readonly userId: Scalars["UUID"]["output"];
};

export type PostCommentsArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<CommentCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<CommentsOrderBy>>;
};

/** A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PostCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  readonly createdAt?: InputMaybe<Scalars["Datetime"]["input"]>;
  /** Checks for equality with the object’s `id` field. */
  readonly id?: InputMaybe<Scalars["String"]["input"]>;
  /** Checks for equality with the object’s `tags` field. */
  readonly tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["Tag"]["input"]>>>;
};

/** An input for mutations affecting `Post` */
export type PostInput = {
  readonly body: Scalars["String"]["input"];
  readonly privacy?: InputMaybe<Privacy>;
  readonly tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["Tag"]["input"]>>>;
  readonly title: Scalars["String"]["input"];
};

/** Represents an update to a `Post`. Fields that are set will be updated. */
export type PostPatch = {
  readonly body?: InputMaybe<Scalars["String"]["input"]>;
  readonly privacy?: InputMaybe<Privacy>;
  readonly tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["Tag"]["input"]>>>;
  readonly title?: InputMaybe<Scalars["String"]["input"]>;
};

/** A connection to a list of `Post` values. */
export type PostsConnection = {
  /** A list of edges which contains the `Post` and cursor to aid in pagination. */
  readonly edges: ReadonlyArray<PostsEdge>;
  /** A list of `Post` objects. */
  readonly nodes: ReadonlyArray<Post>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  readonly totalCount: Scalars["Int"]["output"];
};

/** A `Post` edge in the connection. */
export type PostsEdge = {
  /** A cursor for use in pagination. */
  readonly cursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** The `Post` at the end of the edge. */
  readonly node: Post;
};

/** Methods to use when ordering `Post`. */
export type PostsOrderBy =
  | "CREATED_AT_ASC"
  | "CREATED_AT_DESC"
  | "ID_ASC"
  | "ID_DESC"
  | "NATURAL"
  | "PRIMARY_KEY_ASC"
  | "PRIMARY_KEY_DESC";

export type Privacy = "PRIVATE" | "PUBLIC";

/** The root query type which gives access points into the data universe. */
export type Query = {
  /** Get a single `Comment`. */
  readonly comment?: Maybe<Comment>;
  /** Reads and enables pagination through a set of `Comment`. */
  readonly comments?: Maybe<CommentsConnection>;
  /** The currently logged in user (or null if not logged in). */
  readonly currentUser?: Maybe<User>;
  /** Get a single `Post`. */
  readonly post?: Maybe<Post>;
  /** Reads and enables pagination through a set of `Post`. */
  readonly posts?: Maybe<PostsConnection>;
  readonly postsByTags?: Maybe<Post>;
  /** Get a single `Task`. */
  readonly task?: Maybe<Task>;
  /** Reads and enables pagination through a set of `Task`. */
  readonly tasks?: Maybe<TasksConnection>;
  /** Reads and enables pagination through a set of `TopTag`. */
  readonly topTags?: Maybe<TopTagsConnection>;
  /** Get a single `User`. */
  readonly user?: Maybe<User>;
  /** Get a single `UserAuthentication`. */
  readonly userAuthentication?: Maybe<UserAuthentication>;
  /** Get a single `User`. */
  readonly userByUsername?: Maybe<User>;
  /** Get a single `UserEmail`. */
  readonly userEmail?: Maybe<UserEmail>;
};

/** The root query type which gives access points into the data universe. */
export type QueryCommentArgs = {
  id: Scalars["UUID"]["input"];
};

/** The root query type which gives access points into the data universe. */
export type QueryCommentsArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<CommentCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<CommentsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPostArgs = {
  id: Scalars["String"]["input"];
};

/** The root query type which gives access points into the data universe. */
export type QueryPostsArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<PostCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<PostsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPostsByTagsArgs = {
  tags: ReadonlyArray<InputMaybe<Scalars["String"]["input"]>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTaskArgs = {
  id: Scalars["UUID"]["input"];
};

/** The root query type which gives access points into the data universe. */
export type QueryTasksArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<TaskCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<TasksOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTopTagsArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars["UUID"]["input"];
};

/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationArgs = {
  id: Scalars["UUID"]["input"];
};

/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars["Username"]["input"];
};

/** The root query type which gives access points into the data universe. */
export type QueryUserEmailArgs = {
  id: Scalars["UUID"]["input"];
};

export type RegisterInput = {
  readonly avatarUrl?: InputMaybe<Scalars["String"]["input"]>;
  readonly email: Scalars["String"]["input"];
  readonly name?: InputMaybe<Scalars["String"]["input"]>;
  readonly password: Scalars["String"]["input"];
  readonly username: Scalars["String"]["input"];
};

export type RegisterPayload = {
  readonly user: User;
};

/** All input for the `requestAccountDeletion` mutation. */
export type RequestAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** The output of our `requestAccountDeletion` mutation. */
export type RequestAccountDeletionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** All input for the `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly emailId: Scalars["UUID"]["input"];
};

/** The output of our `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly newPassword: Scalars["String"]["input"];
  readonly resetToken: Scalars["String"]["input"];
  readonly userId: Scalars["UUID"]["input"];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

/** The root subscription type: contains realtime events you can subscribe to with the `subscription` operation. */
export type Subscription = {
  /** Triggered when the logged in user's record is updated in some way. */
  readonly currentUserUpdated?: Maybe<UserSubscriptionPayload>;
};

export type Task = {
  readonly createdAt: Scalars["Datetime"]["output"];
  readonly description?: Maybe<Scalars["String"]["output"]>;
  readonly id: Scalars["UUID"]["output"];
  readonly status?: Maybe<TaskStatus>;
  readonly tags: ReadonlyArray<Maybe<Scalars["String"]["output"]>>;
  readonly title: Scalars["String"]["output"];
  readonly updatedAt: Scalars["Datetime"]["output"];
  /** Reads a single `User` that is related to this `Task`. */
  readonly user?: Maybe<User>;
  readonly userId: Scalars["UUID"]["output"];
};

/** A condition to be used against `Task` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TaskCondition = {
  /** Checks for equality with the object’s `id` field. */
  readonly id?: InputMaybe<Scalars["UUID"]["input"]>;
  /** Checks for equality with the object’s `tags` field. */
  readonly tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["String"]["input"]>>>;
  /** Checks for equality with the object’s `userId` field. */
  readonly userId?: InputMaybe<Scalars["UUID"]["input"]>;
};

/** An input for mutations affecting `Task` */
export type TaskInput = {
  readonly description?: InputMaybe<Scalars["String"]["input"]>;
  readonly tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["String"]["input"]>>>;
  readonly title: Scalars["String"]["input"];
};

/** Represents an update to a `Task`. Fields that are set will be updated. */
export type TaskPatch = {
  readonly description?: InputMaybe<Scalars["String"]["input"]>;
  readonly tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["String"]["input"]>>>;
  readonly title?: InputMaybe<Scalars["String"]["input"]>;
};

export type TaskStatus = "ABANDONED" | "COMPLETED" | "PENDING" | "STARTED";

/** A connection to a list of `Task` values. */
export type TasksConnection = {
  /** A list of edges which contains the `Task` and cursor to aid in pagination. */
  readonly edges: ReadonlyArray<TasksEdge>;
  /** A list of `Task` objects. */
  readonly nodes: ReadonlyArray<Task>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The count of *all* `Task` you could get from the connection. */
  readonly totalCount: Scalars["Int"]["output"];
};

/** A `Task` edge in the connection. */
export type TasksEdge = {
  /** A cursor for use in pagination. */
  readonly cursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** The `Task` at the end of the edge. */
  readonly node: Task;
};

/** Methods to use when ordering `Task`. */
export type TasksOrderBy =
  | "ID_ASC"
  | "ID_DESC"
  | "NATURAL"
  | "PRIMARY_KEY_ASC"
  | "PRIMARY_KEY_DESC"
  | "USER_ID_ASC"
  | "USER_ID_DESC";

export type TopTag = {
  readonly count?: Maybe<Scalars["BigInt"]["output"]>;
  readonly tag?: Maybe<Scalars["Tag"]["output"]>;
};

/** A connection to a list of `TopTag` values. */
export type TopTagsConnection = {
  /** A list of edges which contains the `TopTag` and cursor to aid in pagination. */
  readonly edges: ReadonlyArray<TopTagsEdge>;
  /** A list of `TopTag` objects. */
  readonly nodes: ReadonlyArray<TopTag>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The count of *all* `TopTag` you could get from the connection. */
  readonly totalCount: Scalars["Int"]["output"];
};

/** A `TopTag` edge in the connection. */
export type TopTagsEdge = {
  /** A cursor for use in pagination. */
  readonly cursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** The `TopTag` at the end of the edge. */
  readonly node: TopTag;
};

/** All input for the `updateComment` mutation. */
export type UpdateCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["UUID"]["input"];
  /** An object where the defined keys will be set on the `Comment` being updated. */
  readonly patch: CommentPatch;
};

/** The output of our update `Comment` mutation. */
export type UpdateCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The `Comment` that was updated by this mutation. */
  readonly comment?: Maybe<Comment>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  readonly commentEdge?: Maybe<CommentsEdge>;
  /** Reads a single `Comment` that is related to this `Comment`. */
  readonly parent?: Maybe<Comment>;
  /** Reads a single `Post` that is related to this `Comment`. */
  readonly post?: Maybe<Post>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Comment`. */
  readonly user?: Maybe<User>;
};

/** The output of our update `Comment` mutation. */
export type UpdateCommentPayloadCommentEdgeArgs = {
  orderBy?: ReadonlyArray<CommentsOrderBy>;
};

/** All input for the `updatePost` mutation. */
export type UpdatePostInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["String"]["input"];
  /** An object where the defined keys will be set on the `Post` being updated. */
  readonly patch: PostPatch;
};

/** The output of our update `Post` mutation. */
export type UpdatePostPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The `Post` that was updated by this mutation. */
  readonly post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  readonly postEdge?: Maybe<PostsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Post`. */
  readonly user?: Maybe<User>;
};

/** The output of our update `Post` mutation. */
export type UpdatePostPayloadPostEdgeArgs = {
  orderBy?: ReadonlyArray<PostsOrderBy>;
};

/** All input for the `updateTask` mutation. */
export type UpdateTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly id: Scalars["UUID"]["input"];
  /** An object where the defined keys will be set on the `Task` being updated. */
  readonly patch: TaskPatch;
};

/** The output of our update `Task` mutation. */
export type UpdateTaskPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** The `Task` that was updated by this mutation. */
  readonly task?: Maybe<Task>;
  /** An edge for our `Task`. May be used by Relay 1. */
  readonly taskEdge?: Maybe<TasksEdge>;
  /** Reads a single `User` that is related to this `Task`. */
  readonly user?: Maybe<User>;
};

/** The output of our update `Task` mutation. */
export type UpdateTaskPayloadTaskEdgeArgs = {
  orderBy?: ReadonlyArray<TasksOrderBy>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Unique identifier for the user. */
  readonly id: Scalars["UUID"]["input"];
  /** An object where the defined keys will be set on the `User` being updated. */
  readonly patch: UserPatch;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  readonly user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  readonly userEdge?: Maybe<UsersEdge>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: ReadonlyArray<UsersOrderBy>;
};

/** A user who can log in to the application. */
export type User = {
  /** Optional avatar URL. */
  readonly avatarUrl?: Maybe<Scalars["Url"]["output"]>;
  readonly createdAt: Scalars["Datetime"]["output"];
  readonly hasPassword?: Maybe<Scalars["Boolean"]["output"]>;
  /** Unique identifier for the user. */
  readonly id: Scalars["UUID"]["output"];
  readonly isVerified: Scalars["Boolean"]["output"];
  /** Public-facing name (or pseudonym) of the user. */
  readonly name?: Maybe<Scalars["String"]["output"]>;
  /** If admin, the user has elevated privileges. */
  readonly role: UserRole;
  /** Reads and enables pagination through a set of `Task`. */
  readonly tasks: TasksConnection;
  readonly updatedAt: Scalars["Datetime"]["output"];
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  readonly userAuthenticationsList: ReadonlyArray<UserAuthentication>;
  /** Reads and enables pagination through a set of `UserEmail`. */
  readonly userEmails: UserEmailsConnection;
  /** Public-facing username (or 'handle') of the user. */
  readonly username: Scalars["Username"]["output"];
};

/** A user who can log in to the application. */
export type UserTasksArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<TaskCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<TasksOrderBy>>;
};

/** A user who can log in to the application. */
export type UserUserAuthenticationsListArgs = {
  condition?: InputMaybe<UserAuthenticationCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<UserAuthenticationsOrderBy>>;
};

/** A user who can log in to the application. */
export type UserUserEmailsArgs = {
  after?: InputMaybe<Scalars["Cursor"]["input"]>;
  before?: InputMaybe<Scalars["Cursor"]["input"]>;
  condition?: InputMaybe<UserEmailCondition>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<ReadonlyArray<UserEmailsOrderBy>>;
};

/** Contains information about the login providers this user has used, so that they may disconnect them should they wish. */
export type UserAuthentication = {
  readonly createdAt: Scalars["Datetime"]["output"];
  readonly id: Scalars["UUID"]["output"];
  /** A unique identifier for the user within the login service. */
  readonly identifier: Scalars["String"]["output"];
  /** The login service used, e.g. `twitter` or `github`. */
  readonly service: Scalars["String"]["output"];
  readonly updatedAt: Scalars["Datetime"]["output"];
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  readonly user?: Maybe<User>;
  readonly userId: Scalars["UUID"]["output"];
};

/**
 * A condition to be used against `UserAuthentication` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserAuthenticationCondition = {
  /** Checks for equality with the object’s `id` field. */
  readonly id?: InputMaybe<Scalars["UUID"]["input"]>;
  /** Checks for equality with the object’s `service` field. */
  readonly service?: InputMaybe<Scalars["String"]["input"]>;
  /** Checks for equality with the object’s `userId` field. */
  readonly userId?: InputMaybe<Scalars["UUID"]["input"]>;
};

/** Methods to use when ordering `UserAuthentication`. */
export type UserAuthenticationsOrderBy =
  | "ID_ASC"
  | "ID_DESC"
  | "NATURAL"
  | "PRIMARY_KEY_ASC"
  | "PRIMARY_KEY_DESC"
  | "SERVICE_ASC"
  | "SERVICE_DESC"
  | "USER_ID_ASC"
  | "USER_ID_DESC";

/** Information about a user's email address. */
export type UserEmail = {
  readonly createdAt: Scalars["Datetime"]["output"];
  /** The users email address, in `a@b.c` format. */
  readonly email: Scalars["String"]["output"];
  readonly id: Scalars["UUID"]["output"];
  readonly isPrimary: Scalars["Boolean"]["output"];
  /** True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise. */
  readonly isVerified: Scalars["Boolean"]["output"];
  readonly updatedAt: Scalars["Datetime"]["output"];
  /** Reads a single `User` that is related to this `UserEmail`. */
  readonly user?: Maybe<User>;
  readonly userId: Scalars["UUID"]["output"];
};

/**
 * A condition to be used against `UserEmail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserEmailCondition = {
  /** Checks for equality with the object’s `id` field. */
  readonly id?: InputMaybe<Scalars["UUID"]["input"]>;
  /** Checks for equality with the object’s `isPrimary` field. */
  readonly isPrimary?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Checks for equality with the object’s `userId` field. */
  readonly userId?: InputMaybe<Scalars["UUID"]["input"]>;
};

/** An input for mutations affecting `UserEmail` */
export type UserEmailInput = {
  /** The users email address, in `a@b.c` format. */
  readonly email: Scalars["String"]["input"];
};

/** A connection to a list of `UserEmail` values. */
export type UserEmailsConnection = {
  /** A list of edges which contains the `UserEmail` and cursor to aid in pagination. */
  readonly edges: ReadonlyArray<UserEmailsEdge>;
  /** A list of `UserEmail` objects. */
  readonly nodes: ReadonlyArray<UserEmail>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The count of *all* `UserEmail` you could get from the connection. */
  readonly totalCount: Scalars["Int"]["output"];
};

/** A `UserEmail` edge in the connection. */
export type UserEmailsEdge = {
  /** A cursor for use in pagination. */
  readonly cursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** The `UserEmail` at the end of the edge. */
  readonly node: UserEmail;
};

/** Methods to use when ordering `UserEmail`. */
export type UserEmailsOrderBy =
  | "ID_ASC"
  | "ID_DESC"
  | "IS_PRIMARY_ASC"
  | "IS_PRIMARY_DESC"
  | "NATURAL"
  | "PRIMARY_KEY_ASC"
  | "PRIMARY_KEY_DESC"
  | "USER_ID_ASC"
  | "USER_ID_DESC";

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  /** Optional avatar URL. */
  readonly avatarUrl?: InputMaybe<Scalars["Url"]["input"]>;
  /** Public-facing name (or pseudonym) of the user. */
  readonly name?: InputMaybe<Scalars["String"]["input"]>;
  /** Public-facing username (or 'handle') of the user. */
  readonly username?: InputMaybe<Scalars["Username"]["input"]>;
};

export type UserRole = "ADMIN" | "USER";

export type UserSubscriptionPayload = {
  readonly event?: Maybe<Scalars["String"]["output"]>;
  readonly user?: Maybe<User>;
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  /** A cursor for use in pagination. */
  readonly cursor?: Maybe<Scalars["Cursor"]["output"]>;
  /** The `User` at the end of the edge. */
  readonly node: User;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | "ID_ASC"
  | "ID_DESC"
  | "NATURAL"
  | "PRIMARY_KEY_ASC"
  | "PRIMARY_KEY_DESC"
  | "USERNAME_ASC"
  | "USERNAME_DESC";

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  readonly clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  readonly token: Scalars["String"]["input"];
  readonly userEmailId: Scalars["UUID"]["input"];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  readonly clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  readonly query?: Maybe<Query>;
  readonly success?: Maybe<Scalars["Boolean"]["output"]>;
};

export type VoteType = "DOWN" | "UP";

export type AddEmailMutationVariables = Exact<{
  email: Scalars["String"]["input"];
}>;

export type AddEmailMutation = {
  readonly createUserEmail?: {
    readonly user?: {
      readonly id: string;
      readonly userEmails: {
        readonly nodes: ReadonlyArray<{
          readonly id: string;
          readonly email: string;
          readonly isVerified: boolean;
          readonly isPrimary: boolean;
          readonly createdAt: string;
        }>;
      };
    } | null;
  } | null;
};

export type ChangePasswordMutationVariables = Exact<{
  oldPassword: Scalars["String"]["input"];
  newPassword: Scalars["String"]["input"];
}>;

export type ChangePasswordMutation = {
  readonly changePassword?: { readonly success?: boolean | null } | null;
};

export type ConfirmAccountDeletionMutationVariables = Exact<{
  token: Scalars["String"]["input"];
}>;

export type ConfirmAccountDeletionMutation = {
  readonly confirmAccountDeletion?: { readonly success?: boolean | null } | null;
};

export type CreatePostMutationVariables = Exact<{
  title: Scalars["String"]["input"];
  body: Scalars["String"]["input"];
  tags: ReadonlyArray<InputMaybe<Scalars["Tag"]["input"]>> | InputMaybe<Scalars["Tag"]["input"]>;
}>;

export type CreatePostMutation = {
  readonly createPost?: {
    readonly post?: { readonly id: string; readonly createdAt: string } | null;
  } | null;
};

export type CurrentUserUpdatedSubscriptionVariables = Exact<{ [key: string]: never }>;

export type CurrentUserUpdatedSubscription = {
  readonly currentUserUpdated?: {
    readonly event?: string | null;
    readonly user?: {
      readonly id: string;
      readonly username: string;
      readonly name?: string | null;
      readonly avatarUrl?: string | null;
      readonly role: UserRole;
      readonly isVerified: boolean;
    } | null;
  } | null;
};

export type DeleteEmailMutationVariables = Exact<{
  emailId: Scalars["UUID"]["input"];
}>;

export type DeleteEmailMutation = {
  readonly deleteUserEmail?: {
    readonly user?: {
      readonly id: string;
      readonly userEmails: {
        readonly nodes: ReadonlyArray<{
          readonly id: string;
          readonly email: string;
          readonly isVerified: boolean;
          readonly isPrimary: boolean;
          readonly createdAt: string;
        }>;
      };
    } | null;
  } | null;
};

export type EmailsForm_UserEmailFragment = {
  readonly id: string;
  readonly email: string;
  readonly isVerified: boolean;
  readonly isPrimary: boolean;
  readonly createdAt: string;
};

export type ForgotPasswordMutationVariables = Exact<{
  email: Scalars["String"]["input"];
}>;

export type ForgotPasswordMutation = {
  readonly forgotPassword?: { readonly clientMutationId?: string | null } | null;
};

export type LatestPostsQueryVariables = Exact<{ [key: string]: never }>;

export type LatestPostsQuery = {
  readonly posts?: {
    readonly nodes: ReadonlyArray<{
      readonly id: string;
      readonly title: string;
      readonly body: string;
      readonly tags: ReadonlyArray<string | null>;
      readonly score?: number | null;
      readonly createdAt: string;
      readonly updatedAt: string;
      readonly user?: { readonly username: string } | null;
      readonly comments: { readonly totalCount: number };
    }>;
  } | null;
  readonly currentUser?: {
    readonly id: string;
    readonly name?: string | null;
    readonly username: string;
    readonly avatarUrl?: string | null;
    readonly role: UserRole;
    readonly isVerified: boolean;
  } | null;
};

export type LoginMutationVariables = Exact<{
  username: Scalars["String"]["input"];
  password: Scalars["String"]["input"];
}>;

export type LoginMutation = {
  readonly login?: {
    readonly user: {
      readonly id: string;
      readonly username: string;
      readonly name?: string | null;
    };
  } | null;
};

export type LogoutMutationVariables = Exact<{ [key: string]: never }>;

export type LogoutMutation = { readonly logout?: { readonly success?: boolean | null } | null };

export type MakeEmailPrimaryMutationVariables = Exact<{
  emailId: Scalars["UUID"]["input"];
}>;

export type MakeEmailPrimaryMutation = {
  readonly makeEmailPrimary?: {
    readonly user?: {
      readonly id: string;
      readonly userEmails: {
        readonly nodes: ReadonlyArray<{ readonly id: string; readonly isPrimary: boolean }>;
      };
    } | null;
  } | null;
};

export type PostFieldsFragment = {
  readonly id: string;
  readonly title: string;
  readonly body: string;
  readonly tags: ReadonlyArray<string | null>;
  readonly score?: number | null;
  readonly createdAt: string;
  readonly updatedAt: string;
  readonly user?: { readonly username: string } | null;
  readonly comments: { readonly totalCount: number };
};

export type RegisterMutationVariables = Exact<{
  username: Scalars["String"]["input"];
  password: Scalars["String"]["input"];
  email: Scalars["String"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
}>;

export type RegisterMutation = {
  readonly register?: {
    readonly user: {
      readonly id: string;
      readonly username: string;
      readonly name?: string | null;
    };
  } | null;
};

export type RequestAccountDeletionMutationVariables = Exact<{ [key: string]: never }>;

export type RequestAccountDeletionMutation = {
  readonly requestAccountDeletion?: { readonly success?: boolean | null } | null;
};

export type ResendEmailVerificationMutationVariables = Exact<{
  emailId: Scalars["UUID"]["input"];
}>;

export type ResendEmailVerificationMutation = {
  readonly resendEmailVerificationCode?: { readonly success?: boolean | null } | null;
};

export type ResetPasswordMutationVariables = Exact<{
  userId: Scalars["UUID"]["input"];
  token: Scalars["String"]["input"];
  password: Scalars["String"]["input"];
}>;

export type ResetPasswordMutation = {
  readonly resetPassword?: { readonly success?: boolean | null } | null;
};

export type ProfileSettingsQueryVariables = Exact<{ [key: string]: never }>;

export type ProfileSettingsQuery = {
  readonly currentUser?: {
    readonly id: string;
    readonly isVerified: boolean;
    readonly hasPassword?: boolean | null;
    readonly name?: string | null;
    readonly username: string;
    readonly avatarUrl?: string | null;
    readonly role: UserRole;
    readonly userEmails: {
      readonly nodes: ReadonlyArray<{
        readonly id: string;
        readonly email: string;
        readonly isVerified: boolean;
        readonly isPrimary: boolean;
        readonly createdAt: string;
      }>;
    };
    readonly authentications: ReadonlyArray<{
      readonly id: string;
      readonly service: string;
      readonly identifier: string;
      readonly createdAt: string;
    }>;
  } | null;
};

export type SharedLayoutQueryVariables = Exact<{ [key: string]: never }>;

export type SharedLayoutQuery = {
  readonly currentUser?: {
    readonly id: string;
    readonly name?: string | null;
    readonly username: string;
    readonly avatarUrl?: string | null;
    readonly role: UserRole;
    readonly isVerified: boolean;
  } | null;
};

export type SharedLayout_QueryFragment = {
  readonly currentUser?: {
    readonly id: string;
    readonly name?: string | null;
    readonly username: string;
    readonly avatarUrl?: string | null;
    readonly role: UserRole;
    readonly isVerified: boolean;
  } | null;
};

export type SharedLayout_UserFragment = {
  readonly id: string;
  readonly name?: string | null;
  readonly username: string;
  readonly avatarUrl?: string | null;
  readonly role: UserRole;
  readonly isVerified: boolean;
};

export type UnlinkUserAuthenticationMutationVariables = Exact<{
  id: Scalars["UUID"]["input"];
}>;

export type UnlinkUserAuthenticationMutation = {
  readonly deleteUserAuthentication?: {
    readonly user?: {
      readonly id: string;
      readonly userAuthenticationsList: ReadonlyArray<{
        readonly id: string;
        readonly identifier: string;
        readonly service: string;
        readonly createdAt: string;
      }>;
    } | null;
  } | null;
};

export type UpdateUserMutationVariables = Exact<{
  id: Scalars["UUID"]["input"];
  patch: UserPatch;
}>;

export type UpdateUserMutation = {
  readonly updateUser?: {
    readonly clientMutationId?: string | null;
    readonly user?: {
      readonly id: string;
      readonly name?: string | null;
      readonly username: string;
    } | null;
  } | null;
};

export type VerifyEmailMutationVariables = Exact<{
  id: Scalars["UUID"]["input"];
  token: Scalars["String"]["input"];
}>;

export type VerifyEmailMutation = {
  readonly verifyEmail?: {
    readonly success?: boolean | null;
    readonly query?: {
      readonly currentUser?: {
        readonly id: string;
        readonly name?: string | null;
        readonly username: string;
        readonly avatarUrl?: string | null;
        readonly role: UserRole;
        readonly isVerified: boolean;
      } | null;
    } | null;
  } | null;
};

export const EmailsForm_UserEmailFragmentDoc = gql`
  fragment EmailsForm_UserEmail on UserEmail {
    id
    email
    isVerified
    isPrimary
    createdAt
  }
` as unknown as DocumentNode<EmailsForm_UserEmailFragment, unknown>;
export const PostFieldsFragmentDoc = gql`
  fragment PostFields on Post {
    id
    user {
      username
    }
    title
    body
    tags
    score
    comments {
      totalCount
    }
    createdAt
    updatedAt
  }
` as unknown as DocumentNode<PostFieldsFragment, unknown>;
export const SharedLayout_UserFragmentDoc = gql`
  fragment SharedLayout_User on User {
    id
    name
    username
    avatarUrl
    role
    isVerified
  }
` as unknown as DocumentNode<SharedLayout_UserFragment, unknown>;
export const SharedLayout_QueryFragmentDoc = gql`
  fragment SharedLayout_Query on Query {
    currentUser {
      ...SharedLayout_User
    }
  }
  ${SharedLayout_UserFragmentDoc}
` as unknown as DocumentNode<SharedLayout_QueryFragment, unknown>;
export const AddEmailDocument = gql`
  mutation AddEmail($email: String!) {
    createUserEmail(input: { userEmail: { email: $email } }) {
      user {
        id
        userEmails(first: 50) {
          nodes {
            id
            ...EmailsForm_UserEmail
          }
        }
      }
    }
  }
  ${EmailsForm_UserEmailFragmentDoc}
` as unknown as DocumentNode<AddEmailMutation, AddEmailMutationVariables>;
export const ChangePasswordDocument = gql`
  mutation ChangePassword($oldPassword: String!, $newPassword: String!) {
    changePassword(input: { oldPassword: $oldPassword, newPassword: $newPassword }) {
      success
    }
  }
` as unknown as DocumentNode<ChangePasswordMutation, ChangePasswordMutationVariables>;
export const ConfirmAccountDeletionDocument = gql`
  mutation ConfirmAccountDeletion($token: String!) {
    confirmAccountDeletion(input: { token: $token }) {
      success
    }
  }
` as unknown as DocumentNode<
  ConfirmAccountDeletionMutation,
  ConfirmAccountDeletionMutationVariables
>;
export const CreatePostDocument = gql`
  mutation CreatePost($title: String!, $body: String!, $tags: [Tag]!) {
    createPost(input: { post: { title: $title, body: $body, tags: $tags } }) {
      post {
        id
        createdAt
      }
    }
  }
` as unknown as DocumentNode<CreatePostMutation, CreatePostMutationVariables>;
export const CurrentUserUpdatedDocument = gql`
  subscription CurrentUserUpdated {
    currentUserUpdated {
      event
      user {
        id
        username
        name
        avatarUrl
        role
        isVerified
      }
    }
  }
` as unknown as DocumentNode<
  CurrentUserUpdatedSubscription,
  CurrentUserUpdatedSubscriptionVariables
>;
export const DeleteEmailDocument = gql`
  mutation DeleteEmail($emailId: UUID!) {
    deleteUserEmail(input: { id: $emailId }) {
      user {
        id
        userEmails(first: 50) {
          nodes {
            id
            ...EmailsForm_UserEmail
          }
        }
      }
    }
  }
  ${EmailsForm_UserEmailFragmentDoc}
` as unknown as DocumentNode<DeleteEmailMutation, DeleteEmailMutationVariables>;
export const ForgotPasswordDocument = gql`
  mutation ForgotPassword($email: String!) {
    forgotPassword(input: { email: $email }) {
      clientMutationId
    }
  }
` as unknown as DocumentNode<ForgotPasswordMutation, ForgotPasswordMutationVariables>;
export const LatestPostsDocument = gql`
  query LatestPosts {
    ...SharedLayout_Query
    posts(orderBy: CREATED_AT_DESC) {
      nodes {
        ...PostFields
      }
    }
  }
  ${SharedLayout_QueryFragmentDoc}
  ${PostFieldsFragmentDoc}
` as unknown as DocumentNode<LatestPostsQuery, LatestPostsQueryVariables>;
export const LoginDocument = gql`
  mutation Login($username: String!, $password: String!) {
    login(input: { username: $username, password: $password }) {
      user {
        id
        username
        name
      }
    }
  }
` as unknown as DocumentNode<LoginMutation, LoginMutationVariables>;
export const LogoutDocument = gql`
  mutation Logout {
    logout {
      success
    }
  }
` as unknown as DocumentNode<LogoutMutation, LogoutMutationVariables>;
export const MakeEmailPrimaryDocument = gql`
  mutation MakeEmailPrimary($emailId: UUID!) {
    makeEmailPrimary(input: { emailId: $emailId }) {
      user {
        id
        userEmails(first: 50) {
          nodes {
            id
            isPrimary
          }
        }
      }
    }
  }
` as unknown as DocumentNode<MakeEmailPrimaryMutation, MakeEmailPrimaryMutationVariables>;
export const RegisterDocument = gql`
  mutation Register($username: String!, $password: String!, $email: String!, $name: String) {
    register(input: { username: $username, password: $password, email: $email, name: $name }) {
      user {
        id
        username
        name
      }
    }
  }
` as unknown as DocumentNode<RegisterMutation, RegisterMutationVariables>;
export const RequestAccountDeletionDocument = gql`
  mutation RequestAccountDeletion {
    requestAccountDeletion(input: {}) {
      success
    }
  }
` as unknown as DocumentNode<
  RequestAccountDeletionMutation,
  RequestAccountDeletionMutationVariables
>;
export const ResendEmailVerificationDocument = gql`
  mutation ResendEmailVerification($emailId: UUID!) {
    resendEmailVerificationCode(input: { emailId: $emailId }) {
      success
    }
  }
` as unknown as DocumentNode<
  ResendEmailVerificationMutation,
  ResendEmailVerificationMutationVariables
>;
export const ResetPasswordDocument = gql`
  mutation ResetPassword($userId: UUID!, $token: String!, $password: String!) {
    resetPassword(input: { userId: $userId, resetToken: $token, newPassword: $password }) {
      success
    }
  }
` as unknown as DocumentNode<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const ProfileSettingsDocument = gql`
  query ProfileSettings {
    ...SharedLayout_Query
    currentUser {
      id
      isVerified
      hasPassword
      userEmails(first: 50) {
        nodes {
          id
          email
          isVerified
          isPrimary
          createdAt
        }
      }
      authentications: userAuthenticationsList(first: 50) {
        id
        service
        identifier
        createdAt
      }
    }
  }
  ${SharedLayout_QueryFragmentDoc}
` as unknown as DocumentNode<ProfileSettingsQuery, ProfileSettingsQueryVariables>;
export const SharedLayoutDocument = gql`
  query SharedLayout {
    ...SharedLayout_Query
  }
  ${SharedLayout_QueryFragmentDoc}
` as unknown as DocumentNode<SharedLayoutQuery, SharedLayoutQueryVariables>;
export const UnlinkUserAuthenticationDocument = gql`
  mutation UnlinkUserAuthentication($id: UUID!) {
    deleteUserAuthentication(input: { id: $id }) {
      user {
        id
        userAuthenticationsList(first: 50) {
          id
          identifier
          service
          createdAt
        }
      }
    }
  }
` as unknown as DocumentNode<
  UnlinkUserAuthenticationMutation,
  UnlinkUserAuthenticationMutationVariables
>;
export const UpdateUserDocument = gql`
  mutation UpdateUser($id: UUID!, $patch: UserPatch!) {
    updateUser(input: { id: $id, patch: $patch }) {
      clientMutationId
      user {
        id
        name
        username
      }
    }
  }
` as unknown as DocumentNode<UpdateUserMutation, UpdateUserMutationVariables>;
export const VerifyEmailDocument = gql`
  mutation VerifyEmail($id: UUID!, $token: String!) {
    verifyEmail(input: { userEmailId: $id, token: $token }) {
      success
      query {
        ...SharedLayout_Query
      }
    }
  }
  ${SharedLayout_QueryFragmentDoc}
` as unknown as DocumentNode<VerifyEmailMutation, VerifyEmailMutationVariables>;
